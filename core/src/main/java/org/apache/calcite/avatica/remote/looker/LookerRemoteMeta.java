/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.avatica.remote.looker;

import org.apache.calcite.avatica.AvaticaConnection;
import org.apache.calcite.avatica.AvaticaStatement;
import org.apache.calcite.avatica.ColumnMetaData.Rep;
import org.apache.calcite.avatica.Meta;
import org.apache.calcite.avatica.QueryState;
import org.apache.calcite.avatica.remote.RemoteMeta;
import org.apache.calcite.avatica.remote.Service;
import org.apache.calcite.avatica.remote.Service.PrepareAndExecuteRequest;
import org.apache.calcite.avatica.remote.TypedValue;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.looker.sdk.LookerSDK;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import static org.apache.calcite.avatica.remote.looker.utils.LookerSdkFactory.RESULT_FORMAT;
import static org.apache.calcite.avatica.remote.looker.utils.LookerSdkFactory.safeSdkCall;

/**
 * Implementation of Meta that works in tandem with {@link LookerRemoteService} to stream results
 * from the Looker SDK.
 */
public class LookerRemoteMeta extends RemoteMeta implements Meta {
  /** Authenticated LookerSDK lazily set from LookerRemoteService. */
  LookerSDK sdk;

  public LookerRemoteMeta(AvaticaConnection connection, Service service) {
    super(connection, service);
    // this class _must_ be backed by a LookerRemoteService
    assert service.getClass() == LookerRemoteService.class;
  }

  /**
   * An initially empty frame specific to Looker result sets. The {@code statementSlug} is used to
   * begin a streaming query.
   */
  static class LookerFrame extends Frame {
    /** A unique ID for the current SQL statement to run. Prepared and set during
     * {@link LookerRemoteService#apply(PrepareAndExecuteRequest)}. */
    public final String statementSlug;

    private LookerFrame(long offset, boolean done, Iterable<Object> rows, String statementSlug) {
      super(offset, done, rows);
      this.statementSlug = statementSlug;
    }

    /** Creates a {@code LookerFrame} for the statement slug
     * @param statementSlug slug for the prepared statement generated by a Looker instance.
     * @return the {@code firstFrame} for the result set. */
    public static final LookerFrame create(String statementSlug) {
      assert null != statementSlug;
      return new LookerFrame(0, false, Collections.emptyList(), statementSlug);
    }
  }

  LookerSDK getSdk() {
    if (null == sdk) {
      sdk = ((LookerRemoteService) service).sdk;
    }
    return sdk;
  }

  /** Creates a streaming iterable that parses a JSON {@link InputStream} into a series of
   * {@link Frame}s. */
  @Override
  public Iterable<Object> createIterable(StatementHandle h, QueryState state, Signature signature,
      List<TypedValue> parameters, Frame firstFrame) {
    if (LookerFrame.class.isAssignableFrom(firstFrame.getClass())) {
      LookerFrame lookerFrame = (LookerFrame) firstFrame;
      // TODO https://github.com/looker-open-source/sdk-codegen/issues/1341:
      //  Begin write to input stream in separate thread. Stop on first fetchSize.
      //  `doFetch` will read from buffer in fetchSize chunks. This is still sync query because the
      //  SDK does not support true streaming requests.
      ByteArrayInputStream in = new ByteArrayInputStream(safeSdkCall(
          () -> getSdk().getStream().run_sql_query(lookerFrame.statementSlug, RESULT_FORMAT)));
      AvaticaStatement stmt;
      try {
        stmt = connection.lookupStatement(h);
      } catch (SQLException e) {
        throw new RuntimeException(e);
      }
      // TODO bug in Avatica - the statement handle never has the signature updated but it should.
      //  workaround by handing the signature over to the iterable directly.
      return new LookerIterable(stmt, state, firstFrame, in, signature);
    }
    // if this is a normal Frame from Avatica no special treatment is needed.
    return super.createIterable(h, state, signature, parameters, firstFrame);
  }

  /**
   * Iterable that yields an iterator that parses an {@link InputStream} of JSON into a sequence of
   * {@link Meta.Frame}s.
   */
  public class LookerIterable extends FetchIterable implements Iterable<Object> {
    static final String ROWS_KEY = "rows";
    static final String VALUE_KEY = "value";

    final AvaticaStatement statement;
    final QueryState state;
    final Frame firstFrame;
    final JsonParser parser;
    final Signature signature;

    LookerIterable(AvaticaStatement statement, QueryState state, Frame firstFrame,
        InputStream in, Signature signature) {
      super(statement, state, firstFrame);
      assert null != in;
      this.statement = statement;
      this.state = state;
      this.firstFrame = firstFrame;
      this.signature = signature;
      try {
        // Create a streaming parser based on the provided InputStream
        this.parser = new JsonFactory().createParser(in);
      } catch (IOException e) {
        throw new RuntimeException("Failed to init streaming parser", e);
      }
    }

    @Override
    public Iterator<Object> iterator() {
      return new LookerIterator(statement, state, firstFrame);
    }

    /**
     * Iterator that parses an {@link InputStream} of JSON into a sequence of {@link Meta.Frame}s.
     */
    public class LookerIterator extends FetchIterator implements Iterator<Object> {
      LookerIterator(AvaticaStatement stmt, QueryState state, Frame firstFrame) {
        super(stmt, state, firstFrame);
      }

      /** Calls the correct method to read the current value on the stream. The {@code get} methods
       * do not advance the current token, so they can be called multiple times without changing the
       * state of the parser.
       *
       * @param columnTypeRep the internal Avatica representation for this value. It is important to
       * use the {@link Rep} rather than the type name since Avatica represents most datetime values
       * as milliseconds since epoch via {@code long}s or {@code int}s.
       * @return the parsed value. */
      private Object deserializeValue(Rep columnTypeRep) throws IOException {
        switch (columnTypeRep) {
        case PRIMITIVE_BOOLEAN:
        case BOOLEAN:
          return parser.getBooleanValue();
        case PRIMITIVE_BYTE:
        case BYTE:
          return parser.getByteValue();
        case PRIMITIVE_CHAR:
        case CHARACTER:
        case STRING:
          return parser.getValueAsString();
        case PRIMITIVE_SHORT:
        case SHORT:
          return parser.getShortValue();
        case PRIMITIVE_INT:
        case INTEGER:
          return parser.getIntValue();
        case PRIMITIVE_LONG:
        case LONG:
          return parser.getLongValue();
        case PRIMITIVE_FLOAT:
        case FLOAT:
          return parser.getFloatValue();
        case PRIMITIVE_DOUBLE:
        case DOUBLE:
          return parser.getDoubleValue();
        case NUMBER:
          return parser.getBigIntegerValue();
        default:
          throw new RuntimeException("Unable to parse " + columnTypeRep + "from stream!");
        }
      }

      private void seekToRows() throws IOException {
        while (parser.nextToken() != null && !ROWS_KEY.equals(parser.currentName())) {
          // move position to start of `rows`
        }
      }

      private void seekToValue() throws IOException {
        while (parser.nextToken() != null && !VALUE_KEY.equals(parser.currentName())) {
          // seeking to `value` key for the field e.g. `"rows": [{"field_1": {"value": 123 }}]
        }
        // now move to the actual value
        parser.nextToken();
      }

      @Override
      public Frame doFetch(StatementHandle h, long currentOffset, int fetchSize) {
        try {
          if (currentOffset == 0) {
            // TODO: Handle `metadata`. We are currently ignoring it and seeking to `rows` array
            seekToRows();
          }
          int rowsRead = 0;
          List<Object> rows = new ArrayList<>();
          // only read the number of rows requested by the connection config `fetchSize`
          while (rowsRead < fetchSize) {
            // TODO: could probably be optimized
            List<Object> columns = new ArrayList<>();
            // the signature should _always_ have the correct number of columns.
            // if not, something went wrong during query preparation on the Looker instance.
            for (int i = 0; i < signature.columns.size(); i++) {
              seekToValue();
              if (parser.isClosed()) {
                // the stream is closed - all rows should be accounted for
                return new Frame(currentOffset + rowsRead, true, rows);
              }
              // add the value to the column list
              Object value = deserializeValue(signature.columns.get(i).type.rep);
              columns.add(value);
            }
            rows.add(columns);
            rowsRead++;
          }
          // we fetched the allowed number of rows so return the frame with the current batch
          return new Frame(currentOffset + rowsRead, false, rows);
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
  }
}
